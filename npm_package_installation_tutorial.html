
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NPM Part 2: Package Installation</title>
</head>
<body>
    <h1>Node Package Manager (NPM), Part 2: Package Installation</h1>

    <p>In the first part of this series, we learned how to initialize an app with npm. Now that our app is set up, the next step is to install the tools and libraries (also known as "packages") that our app depends on to work properly. Imagine building a car—you wouldn't make every part by hand, right? You’d use pre-made parts like tires, engines, and bolts. npm helps you install those "parts" for your app.</p>

    <h2>Installing Packages with <code>npm install</code></h2>
    <p>To install a package with npm, run the following command in your app's root directory:</p>
    <pre><code>
npm install &lt;package_name_1&gt; &lt;package_name_2&gt;
    </code></pre>

    <p>This command fetches the packages you specify from npm’s giant library and places them in your app’s <code>node_modules</code> folder. It’s like having a robot assistant that goes to the store, picks up the parts you need, and organizes them neatly for you.</p>

    <h3>Example: Installing Specific Versions</h3>
    <p>If you want a specific version of a package, use <code>@&lt;version_number&gt;</code> after the package name. For example, to install version 5 of <strong>react-router</strong> and the latest version of <strong>redux</strong>, you would run:</p>
    <pre><code>
npm install react-router@v5 redux
    </code></pre>

    <p>This command looks up the packages in the npm registry and downloads them, along with any other packages they rely on (called "dependencies"). npm automatically handles the chain reaction of installing everything your app needs, even if one package requires another. This can cause your <code>node_modules</code> folder to grow quickly, which is why we always add it to our <code>.gitignore</code> file so it doesn’t clutter our remote repositories.</p>

    <h3>Why Exclude <code>node_modules</code>? (Analogy: The Junk Drawer)</h3>
    <p>Imagine a drawer in your kitchen where you toss every tool, screw, and random object you’ve ever used. Over time, it becomes a cluttered mess. That’s what happens to the <code>node_modules</code> folder as npm installs package after package. Including it in your remote GitHub repository would just add unnecessary clutter. Instead, we use <code>.gitignore</code> to exclude it, leaving our project clean and organized.</p>

    <h2>Updating <code>package.json</code> with Installed Packages</h2>
    <p>By default, when you install a package with <code>npm install</code>, it gets added to your app’s <code>package.json</code> under a <code>dependencies</code> section. For example, after running <code>npm install react-router@v5 redux</code>, your <code>package.json</code> will update like this:</p>
    <pre><code>
"dependencies": {
  "react-router": "^5.3.4",
  "redux": "^4.2.1"
}
    </code></pre>

    <h3>What Do the Caret (^) and Tilde (~) Mean?</h3>
    <p>The caret (^) and tilde (~) in front of version numbers tell npm how flexible it can be when updating a package:</p>
    <ul>
        <li><strong>Caret (^):</strong> Allows npm to update to any minor version of the package. For example, <code>^4.2.1</code> means npm will install versions between 4.2.1 (inclusive) and 5.0.0 (exclusive).</li>
        <li><strong>Tilde (~):</strong> Allows npm to update to any patch version. For example, <code>~5.3.4</code> means npm will install versions between 5.3.4 (inclusive) and 5.4.0 (exclusive).</li>
    </ul>

    <p>If there’s no caret or tilde, npm will install exactly the version you specify. It’s important to consider whether you want to allow updates to newer versions, as newer versions might introduce changes that haven’t been tested with your app.</p>

    <h3>Note on Version Flexibility (Analogy: Upgrading Your Car)</h3>
    <p>Think of versioning like upgrading parts of your car. If a newer version of the engine fixes bugs or adds features, you might want to upgrade. But what if the new engine doesn’t work as well with the rest of your car? The caret (^) and tilde (~) give you the flexibility to upgrade parts of your app safely, while locking down certain versions when necessary to prevent breaking changes.</p>

    <h2>package-lock.json: Locking in Versions</h2>
    <p>Whenever you install a new package, npm updates or creates a file called <code>package-lock.json</code>. This file locks down the exact versions of all your dependencies (and their dependencies) so that anyone working on your project gets the same versions when they install the app’s dependencies. It’s like a detailed receipt showing every single part your app is using, ensuring consistency across different environments.</p>

    <h2>Installing Development-Only Packages</h2>
    <p>Sometimes you’ll want to install packages that are only needed during development (for testing, debugging, etc.) but aren’t required when your app runs in production. To install these development-only packages, use the <code>-D</code> or <code>--save-dev</code> flag. For example:</p>
    <pre><code>
npm install -D redux-logger
    </code></pre>

    <p>This will add <code>redux-logger</code> under a <code>devDependencies</code> section in <code>package.json</code>:</p>
    <pre><code>
"devDependencies": {
  "redux-logger": "^3.0.6"
}
    </code></pre>

    <p>Packages listed under <code>devDependencies</code> won’t be installed in production environments, which helps keep your app lightweight and efficient.</p>

    <h3>Why Separate Development and Production Packages?</h3>
    <p>Imagine building a house. During construction, you use scaffolding, ladders, and power tools, but once the house is finished, you don’t leave the tools lying around. Similarly, development packages (like testing frameworks) help during the "construction" phase of your app, but you don’t need them when the app is deployed to users.</p>

    <h2>Installing All Dependencies</h2>
    <p>Once you’ve shared your project with someone else (or even moved it to a different computer), you don’t have to manually install every single package. Thanks to <code>package.json</code>, anyone can download all the dependencies for your project with a single command:</p>
    <pre><code>
npm install
    </code></pre>

    <p>This command reads the list of dependencies in <code>package.json</code> and installs everything your app needs in one fell swoop. It’s like showing up at a car workshop with a parts list, and the mechanic gathers all the necessary components for you automatically.</p>

    <h2>Conclusion</h2>
    <p>Using npm to install and manage packages makes it easier to incorporate powerful tools and libraries into your app. Whether you're installing packages for production or development, npm helps you keep track of all your dependencies. In the next section, we’ll learn how to update and run these packages. Stay tuned!</p>

</body>
</html>
